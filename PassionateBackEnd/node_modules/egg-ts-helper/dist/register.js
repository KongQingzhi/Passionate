"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Register = void 0;
const tslib_1 = require("tslib");
const cluster_1 = tslib_1.__importDefault(require("cluster"));
const debug_1 = tslib_1.__importDefault(require("debug"));
const core_1 = tslib_1.__importDefault(require("./core"));
const util = tslib_1.__importStar(require("./utils"));
const debug = (0, debug_1.default)('egg-ts-helper#register');
class Register {
    constructor(options) {
        this.tsHelperClazz = (options === null || options === void 0 ? void 0 : options.tsHelperClazz) || core_1.default;
    }
    init(options) {
        /* istanbul ignore else */
        if (!cluster_1.default.isMaster)
            return;
        // make sure ets only run once
        const pid = process.env.ETS_REGISTER_PID;
        if (pid) {
            return debug('egg-ts-helper watcher has ran in %s', pid);
        }
        const watch = util.convertString(process.env.ETS_WATCH, process.env.NODE_ENV !== 'test');
        const clazz = this.tsHelperClazz;
        const cwd = (options === null || options === void 0 ? void 0 : options.cwd) || process.cwd();
        const instance = new clazz(Object.assign({ watch }, options));
        if (util.checkMaybeIsJsProj(cwd)) {
            // write jsconfig if the project is wrote by js
            util.writeJsConfig(cwd);
        }
        else {
            const tsNodeMode = process.env.EGG_TYPESCRIPT === 'true';
            // no need to clean in js project
            // clean local js file at first.
            // because egg-loader cannot load the same property name to egg.
            if (tsNodeMode && instance.config.autoRemoveJs) {
                util.cleanJs(cwd);
            }
        }
        // cache pid to env, prevent child process executing ets again
        process.env.ETS_REGISTER_PID = `${process.pid}`;
        // exec building
        instance.build();
    }
}
exports.default = Register;
exports.Register = Register;
