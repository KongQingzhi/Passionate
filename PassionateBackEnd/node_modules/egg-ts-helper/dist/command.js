"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Command = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const commander_1 = require("commander");
Object.defineProperty(exports, "Command", { enumerable: true, get: function () { return commander_1.Command; } });
const assert_1 = tslib_1.__importDefault(require("assert"));
const package_json_1 = tslib_1.__importDefault(require("../package.json"));
const core_1 = tslib_1.__importStar(require("./core"));
const utils_1 = require("./utils");
class Commander {
    constructor(options) {
        this.commands = (0, utils_1.loadModules)(path_1.default.resolve(__dirname, './cmd'), true);
        this.tsHelperClazz = (options === null || options === void 0 ? void 0 : options.tsHelperClazz) || core_1.default;
        this.program = new commander_1.Command()
            .version((options === null || options === void 0 ? void 0 : options.version) || package_json_1.default.version, '-v, --version')
            .usage('[commands] [options]')
            .option('-w, --watch', 'Watching files, d.ts would recreated while file changed')
            .option('-c, --cwd [path]', 'Egg application base dir (default: process.cwd)')
            .option('-C, --config [path]', 'Configuration file, The argument can be a file path to a valid JSON/JS configuration file.ï¼ˆdefault: {cwd}/tshelper.js')
            .option('-f, --framework [name]', 'Egg framework(default: egg)')
            .option('-o, --oneForAll [path]', 'Create a d.ts import all types (default: typings/ets.d.ts)')
            .option('-s, --silent', 'Running without output')
            .option('-i, --ignore [dirs]', 'Ignore watchDirs, your can ignore multiple dirs with comma like: -i controller,service')
            .option('-e, --enabled [dirs]', 'Enable watchDirs, your can enable multiple dirs with comma like: -e proxy,other')
            .option('-E, --extra [json]', 'Extra config, the value should be json string');
    }
    init(argv) {
        const { program, commands } = this;
        let executeCmd;
        // override executeSubCommand to support async subcommand.
        program.addImplicitHelpCommand = () => { };
        program.executeSubCommand = async function (argv, args, unknown) {
            const cwd = this.cwd || core_1.defaultConfig.cwd;
            const command = commands[executeCmd];
            (0, assert_1.default)(command, executeCmd + ' does not exist');
            await command.run(this, { cwd, argv, args: args.filter(item => item !== this), unknown });
        };
        if (!argv.slice(2).length) {
            this.execute();
        }
        else {
            Object.keys(commands).forEach(cmd => {
                const subCommand = commands[cmd];
                const cmdName = subCommand.options ? `${cmd} ${subCommand.options}` : cmd;
                program.command(cmdName, subCommand.description)
                    .action(command => executeCmd = command);
            });
            program.parse(argv);
            if (!executeCmd) {
                this.execute();
            }
        }
    }
    execute() {
        const { program } = this;
        const watchFiles = program.watch;
        const generatorConfig = {};
        program.ignore && program.ignore.split(',').forEach(key => (generatorConfig[key] = false));
        program.enabled && program.enabled.split(',').forEach(key => (generatorConfig[key] = true));
        const tsHelperConfig = Object.assign({ cwd: program.cwd || core_1.defaultConfig.cwd, framework: program.framework, watch: watchFiles, generatorConfig, configFile: program.config }, (program.extra ? JSON.parse(program.extra) : {}));
        // silent
        if (program.silent) {
            tsHelperConfig.silent = true;
        }
        if ((0, utils_1.checkMaybeIsJsProj)(tsHelperConfig.cwd)) {
            // write jsconfig if the project is wrote by js
            (0, utils_1.writeJsConfig)(tsHelperConfig.cwd);
        }
        // create instance
        const clazz = this.tsHelperClazz;
        const tsHelper = new clazz(tsHelperConfig).build();
        if (program.oneForAll) {
            // create one for all
            tsHelper.createOneForAll(program.oneForAll);
        }
    }
}
exports.default = Commander;
